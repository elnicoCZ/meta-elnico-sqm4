From cba9a7c59ac2e33d4e1b4219261e7e3bd0493ee0 Mon Sep 17 00:00:00 2001
From: Petr Kubiznak <kubiznak.petr@elnico.cz>
Date: Wed, 21 Oct 2020 08:15:20 +0200
Subject: [PATCH] tty/serial/imx: RS485 half-duplex and CTS control fixed

* Support of the SER_RS485_RX_DURING_TX flag added. If not set, RS485
  operates in a half-duplex mode -> RX has to be disabled during TX.

* Support of the SER_RS485_RTS_AFTER_SEND flag fixed. The CTS signal,
  used in place of RTS for RS485 transceiver output control, was not
  properly handled if the flag was not set.

These changes are more or less backports from the driver version
from 2016-08-08 (41d98b5da92f8b7bd11885e7c4797197b5f3e2c3):
https://github.com/Freescale/linux-fslc/blob/41d98b5da92f8b7bd11885e7c4797197b5f3e2c3/drivers/tty/serial/imx.c

Signed-off-by: Petr Kubiznak <kubiznak.petr@elnico.cz>
---
 drivers/tty/serial/imx.c | 22 ++++++++++++++++++----
 1 file changed, 18 insertions(+), 4 deletions(-)

diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
index 79acc2c6061b..49a0d6a7b422 100644
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@ -401,6 +401,7 @@ static void imx_stop_tx(struct uart_port *port)
 			temp &= ~UCR2_CTS;
 		else
 			temp |= UCR2_CTS;
+		temp |= UCR2_RXEN;
 		writel(temp, port->membase + UCR2);
 
 		temp = readl(port->membase + UCR4);
@@ -602,6 +603,8 @@ static void imx_start_tx(struct uart_port *port)
 			temp &= ~UCR2_CTS;
 		else
 			temp |= UCR2_CTS;
+		if (!(port->rs485.flags & SER_RS485_RX_DURING_TX))
+			temp &= ~UCR2_RXEN;
 		writel(temp, port->membase + UCR2);
 
 		temp = readl(port->membase + UCR4);
@@ -1334,16 +1337,21 @@ imx_set_termios(struct uart_port *port, struct ktermios *termios,
 				if (!(port->rs485.flags &
 				      SER_RS485_RTS_AFTER_SEND))
 					ucr2 |= UCR2_CTS;
+				else
+					ucr2 &= ~UCR2_CTS;
 			} else {
 				ucr2 |= UCR2_CTSC;
 			}
 		} else {
 			termios->c_cflag &= ~CRTSCTS;
 		}
-	} else if (port->rs485.flags & SER_RS485_ENABLED)
+	} else if (port->rs485.flags & SER_RS485_ENABLED) {
 		/* disable transmitter */
 		if (!(port->rs485.flags & SER_RS485_RTS_AFTER_SEND))
 			ucr2 |= UCR2_CTS;
+		else
+			ucr2 &= ~UCR2_CTS;
+	}
 
 	if (termios->c_cflag & CSTOPB)
 		ucr2 |= UCR2_STPB;
@@ -1579,19 +1587,17 @@ static int imx_rs485_config(struct uart_port *port,
 			    struct serial_rs485 *rs485conf)
 {
 	struct imx_port *sport = (struct imx_port *)port;
+	unsigned long temp;
 
 	/* unimplemented */
 	rs485conf->delay_rts_before_send = 0;
 	rs485conf->delay_rts_after_send = 0;
-	rs485conf->flags |= SER_RS485_RX_DURING_TX;
 
 	/* RTS is required to control the transmitter */
 	if (!sport->have_rtscts)
 		rs485conf->flags &= ~SER_RS485_ENABLED;
 
 	if (rs485conf->flags & SER_RS485_ENABLED) {
-		unsigned long temp;
-
 		/* disable transmitter */
 		temp = readl(sport->port.membase + UCR2);
 		temp &= ~UCR2_CTSC;
@@ -1602,6 +1608,14 @@ static int imx_rs485_config(struct uart_port *port,
 		writel(temp, sport->port.membase + UCR2);
 	}
 
+	/* Make sure Rx is enabled in case Tx is active with Rx disabled */
+	if (!(rs485conf->flags & SER_RS485_ENABLED) ||
+	    rs485conf->flags & SER_RS485_RX_DURING_TX) {
+		temp = readl(sport->port.membase + UCR2);
+		temp |= UCR2_RXEN;
+		writel(temp, sport->port.membase + UCR2);
+	}
+
 	port->rs485 = *rs485conf;
 
 	return 0;
-- 
2.11.0

